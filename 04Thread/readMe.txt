多线程

首先需要理解  进程！

进程：  我们应用程序的执行实例！有自己独立的内存空间和系统资源！

 一个进程是由一个或者N个线程组成的！
 
线程：cpu调度和分配的基本单位！电脑中真正执行的是 线程！ 

 在同一个时间点，我们的电脑只能运行一个线程！
 
多线程：
     如果在一个进程中，同时运行多个线程，来完成不同的工作，我们称之为多线程！
     
   CPU上能同时运行多个线程吗？  不能！ 
      一个CPU在同一个时间点，只能运行一个线程，但是线程运行的速度太快，我们肉眼无法分辨
      所以我们认为是多线程！  



      
生活中进入地铁站的例子：

  场景1：现在地铁站有1个进站口，同时来了5个人旅客！
               需要排队进站！ 
  场景2：现在地铁站有5个进站口，同时来了5个人旅客！
               不需要排队进站！     
 
 哪个对我们的体验好点呢？
 哪个地铁的设计比较合理呢？

地铁站 ：CPU
进站口 ：线程


多线程的好处：
  01.充分的利用了CPU的资源
  02.给用户带来了良好的体验




实现多线程的方式：

 01.继承Thread类
 02.实现Runnable接口

Thread类   implements  Runnable接口

 Runnable接口中
 01. 只有一个方法run()
 02. 没有返回值
 03. 没有声明异常，其实现类的run（）如果出现了 异常不能声明，只能try catch
 
 
 
 
 
run()和 start()的区别：

   run()：
         01.就是一个普通的方法，称之为线程体！
         02.CPU分配给当前线程时间片的时候，run()开始执行

   start()：
         01.启动线程，不是立即执行线程！
         02.底层会默认执行run()
 
      
线程的生命周期：

    01.新生状态
       MyThreadDemo t1 = new MyThreadDemo();
    02.就绪状态
       t1.start();
    03.运行状态
       run();
    04.阻塞状态
      sleep ,yield, wait , join 
    05.死亡状态
       001.正常死亡      run()执行完毕 之后   
       002.异常死亡      run()执行过程中，出现异常退出！
         

线程的调度
     按照我们特定的方式给 多个线程设置CPU的使用权！
     
 01.线程的优先级
    setPriority()    优先级越高就一定先执行！ 不是的！ 只是一个概率问题
    
    
 02.join() 让新线程加入进来
    t1.join() ：必须等待t1线程执行完毕之后，其他的线程才能执行！
 
 03.线程的休眠
  sleep() 线程调用的时候，占用CPU资源不释放！其他线程就无法获取CPU资源了！
     其他线程需要等待！
   
  wait()  是Object类中的方法！  线程调用wait() 的时候，释放占用的CPU资源！
                01.其他线程继续执行！无需等待！
                02.使用了wait() 的线程，必须notify唤醒才能继续进入就绪状态！
 
 04.线程的礼让   yield      
              概率问题，我们t1线程想让t2线程执行，有可能t2不接收这个让渡！还是t1执行！    
                     
 05.线程的终止
 
   001.   interrupt ： 设置线程的中断状态，不会终止，线程会继续执行！
 
		      如果有线程调用这个方法，那么这个线程的状态就是  中断状态！
		   我们怎么知道这个线程是不是中断状态呢？？？
		   isInterrupted可以判断线程的状态！
  
   002. interrupted：返回线程上次的中断状态！之后清除线程的中断状态！
 
   003. isInterrupted：返回线程是否是中断状态！
   
     
     
  







      
      

