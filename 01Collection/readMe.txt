之前我们学过    数组：
   数组的特点： 
       01.  长度一旦被定义，不允许被改变
       02.  在内存中开辟一连串连续的空间！

那么现在有一个需求：
   让我们定义一个数组  来 保存  新闻信息！！！
   
   问题：
      01.如果定义一个数组 长度为50
                   今天的新闻数量只有10条！ 那么有40个空间被浪费掉了！
      02.今天的新闻数量只有100条！ 那么无法存放多余的50条信息！
           
           
           
在程序的运行过程中，我们不知道需要多少个对象的时候，我们首选集合！！！

 集合框架！
  Vector    线程安全的，但是性能低！
  List      
  Set
  Map
  
  java中的集合框架是 jdk给我们提供好的一些列接口或者类的集合！
   他们都存在于  java.util包中！ 
   
   
  public interface List<E> extends Collection<E>
  public interface Set<E> extends Collection<E>
  
  public interface Map<K,V> 
  
  
 通过观看底层代码 得知：
 
 List   Set 接口都 继承了Collection接口！
   Collection接口中存储的都是不唯一（可以重复），无序的对象！
        List接口中存储的都是不唯一（可以重复），有序（插入顺序）的对象！
                     常用的实现类
                 ArrayList
                 LinkedList
        Set接口中存储的都是唯一（不可以重复），无序的对象！
                       常用的实现类
                 HashSet
                 TreeSet
                 
 Map是单独的接口！
   Map接口存储的是一组键值对(key , value)！key是不允许重复的！
              常用的实现类
              HashMap
              TreeMap
              
  
  
  接口不能被实例化！
  所以我们刚才看到的  List   Set   Map 都应该有对应的实现类！
  我们使用的时候肯定是使用实现类！或者使用多态！
  父类引用指向子类的对象！
  
  
  学数组的时候有没有工具类？？？  Arrays
  
  现在集合中 也有工具类                     Collections 
  
  
  
  
  
  

  
	/**
	 * ArrayList和LinkedList的区别
	 * ArrayList:采用数组的形式来保存数据！这些数据被放在内存中开辟连续的空间！
	 *           每个数据的位置都有下标！ 
	 *           比如说：
	 *           现在集合长度为50！ 现在想删除下标为2的元素！
	 *           删除之后，底层还要做什么操作？
	 *           下标为2之后的元素都要前移？？
	 *           
	 *           现在想在下标为3的位置 新增 元素！
	 *           下标3的元素之后的数据全部后移？？
	 *           所以 新增，删除效率慢！
	 *           因为是数组结构，所以遍历，查询效率高！
	 *           
	 * LinkedList:链表式结构！存储在集合中的每个对象都存放在相互独立的空间！
	 *            比如说： 
	 *             现在集合长度为50！ 
	 *             第1个元素记录第2个元素的位置
	 *             第2个元素记录第3个元素的位置
	 *             。。。。
	 *             第49个元素记录第50个元素的位置
	 *             我们想删除第3个元素！
	 *             只需要让 第2个元素记录第4个元素的位置！
	 *             之后的元素有影响吗？  没有
	 *             
	 *             在第2个元素和第3个元素之间新增一个元素x
	 *             这时候只需要 第2个元素 记录x的位置
	 *             x记录第三个元素的位置
	 *             新增，删除效率高！
	 *             因为没有下标，所以查询遍历的效率低！
	 * 
	 */
  
  
  
  
  
  
  
  
  
  
  
  



















































































